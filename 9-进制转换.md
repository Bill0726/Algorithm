大家都知道，计算机底层计算采用的是二进制，计算机的数据存储也是采用二进制，在网络上，设备与设备之间的通信，最终还是要通过二进制比特流来实现。可以说，二进制是信息时代的基础。那么大家有没有想过，既然计算机采用的是二进制，那为什么我们在电脑、手机上看到的信息是多种多样的呢？这就涉及到进制转换的问题了。比如当我们使用电脑上的计算器计算 98 + 56 时，计算机是先把十进制的 98 和 56 转换成二进制，然后再进行计算。

除了二进制，计算机中比较常用的还用八进制、十六进制等，比如内存地址的表示就是用的十六进制。今天我就带大家学习如何借助「栈」这个数据结构将十进制转换成计算机可以理解的二进制，乃至推广到将十进制转换成任意进制。

先来看一下十进制转二进制的计算过程。就以刚才说的 98 为例，用 2 除 98，取余数，然后再用 2 去除得到的商，取余数……如此循环往复，直到商为零，将余数逆序输出即可得到 98 的二进制表示。具体过程如下：

![](D:\Study\算法与数据结构\邓俊辉\栈\十进制转二进制.png)

最后算出 98 的二进制是 1100010。

与二进制类似，如果要将十进制转换成八进制，也是按照除以 8 取余的方式。以98为例，具体过程如下：

![](D:\Study\算法与数据结构\邓俊辉\栈\十进制转八进制.png)

最后得出 98 的八进制是142。推而广之，如果我们想把十进制转换成 N 进制（N 是大于等于 2 的自然数），就可以按照这种方式来进行计算。

由于我们要将计算过程中产生的余数逆序输出，也就是先产生的数要后输出，这恰恰符合栈的操作规则，所以当我们把该进制转换的算法实现为程序时，就可以用栈来存储计算过程中产生的余数序列。在写程序之前，先来复习一下栈都有哪些操作接口：

| 操作接口 |                   功能                   |
| :------: | :--------------------------------------: |
|  size()  |               报告栈的规模               |
| empty()  |              判断栈是否为空              |
| push(e)  |        将元素 e 插至栈顶（入栈）         |
|  pop()   | 删除栈顶对象，并返回该对象的引用（出栈） |
|  top()   |               引用栈顶对象               |

利用栈的这些操作接口，可以写出代码如下：

```c++
#include "Stack.h"

/*s：一个栈对象
  n：将要被转换的十进制数
  base：进制，若是二进制，则输入 2，若是八进制，则输入 8，以此类推*/
void convert(Stack<char> &s, __int64 n, int base) { //迭代版
    //0 < n, 1 < base <= 16，新进制下的数位符号，可视 base 取值范围适当扩充
	static char digit[16] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
	while (n > 0) { //由低到高，逐一计算出新进制下的各数位
		s.push(digit[n % base]);//余数（当前位）入栈
		n /= base; //将 n 更新为其对 base 的除商
	}
}//新进制下由高到低的各数位，自顶而下保存在栈 s 中
```

本篇文章的代码以及代码中用到的头文件 `Stack.h`均已上传至 GitHub，点击[这里](https://github.com/YoungYo/Algorithm/tree/master/source/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)即可获得。

欢迎关注我的微信公众号，扫描下方二维码或微信搜索：AProgrammer，就可以找到我，我会持续为你分享 IT 技术。

![](https://github.com/YoungYo/Algorithm/blob/master/Images/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg?raw=true)