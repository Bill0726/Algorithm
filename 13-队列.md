目录

[TOC]

# 概述

顾名思义，队列其实就类似于我们现实生活中的排队。在计算机科学中，队列是一种特殊的抽象数据类型(ADT)或集合，保存在这个集合中的实体按线性的逻辑次序排列。对队列中元素的操作，仅限于在队尾和队首进行，其中包括在队尾添加元素（入队，enqueue）以及移除队首的元素（出队，dequeue），这就使队列成为一种先进先出（FIFO，First-In-First-Out）的数据结构。

就像大家都知道的前两天刚发生的 ofo 总部排队退押金时间，也可以看作是一个队列。

![上千位用户聚集到 ofo 总部门口排队退押金](https://raw.githubusercontent.com/YoungYo/Algorithm/master/Images/13-%E9%98%9F%E5%88%97/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20181228110236.jpg)

在这里插句题外话，最近太多关于该不该向小黄车要押金的争论了，不管谁对谁错，毕竟小黄车也是曾经给我们带来过便利的，希望小黄车这次能够挺过去！

言归正传，在先进先出的数据结构中，第一个被添加到队列中的元素也会被第一个移除，这相当于在添加新元素之后，必须在删除新元素之前删除之前添加的所有元素。队列是线性数据结构的一个例子，或者更抽象地说是顺序集合。

队列提供计算机科学、传输和运筹学方面的服务，在这些服务中，各种实体(如数据、对象、人员或事件)被保存在队列中以供稍后处理，此时，队列实际上是作为缓冲区来使用。

# ADT 接口

作为一种抽象数据类型，与栈类似，队列结构也有自己的操作接口。如下表所示。

|       操作 | 功能                       |
| ---------: | -------------------------- |
|     size() | 报告队列的规模（元素总数） |
|    empty() | 判断队列是否为空           |
| enqueue(e) | 将 e 插入队尾              |
|  dequeue() | 删除队首对象               |
|    front() | 引用队首对象               |

# 实现

队列常见的实现方式有两种，一种是基于链表的普通队列，另一种是基于数组的循环队列。

## 基于链表的普通队列

在此前的一篇文章中，我介绍了链表的实现方式，没有读过的朋友可以看看，[手把手教你实现一个链表](https://github.com/YoungYo/Algorithm/blob/master/6-%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8.md)。在这一节中，我们将在这篇文章的基础上来实现队列。按照上文中描述的队列的操作接口，可实现 Queue 模板类如下：

```cpp
#pragma once
#include "LinkedList.h"

template <typename T> class Queue {
private:
	LinkedList<T> list;
public:
	int size() {
		return list.size();
	}

	bool empty() {
		return list.empty();
	}

	void enqueue(T const& e) { //入队，从尾部插入
		list.insertAsLast(e);
	}

	T dequeue() { //出队，从首部删除
		return list.remove(list.first());
	}

	T& front() { //队首
		return list.first()->data;
	}
};
```

![](https://raw.githubusercontent.com/YoungYo/Algorithm/master/Images/13-%E9%98%9F%E5%88%97/%E9%98%9F%E5%88%97%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

这种基于链表的实现方式比较简单，也容易理解。而且它还继承了链表的最大的优点，那就是在内存允许的情况下，可以无限地往里面添加元素，也就是进行入队操作。

## 基于数组的循环队列

大家都知道，数组是一种顺序存储结构。但是在逻辑上，我们可以将其想象成一个环